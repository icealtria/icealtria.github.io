<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>icealtria&apos;s blog</title><description>A simple blog theme for Astro</description><link>https://icealtria.github.io/<follow_challenge><feedId>60885767001155584</feedId><userId>41755107772433408</userId></follow_challenge><item><title>如何实现一个简单的 Passkey 登录</title><link>https://icealtria.github.io/blog/passkey-101/<guid ispermalink="true">https://icealtria.github.io/blog/passkey-101/</guid><pubDate>Mon, 09 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近糊了个 &lt;a href=&quot;https://meow-counter.icealtria.workers.dev/&quot;&gt;meow-counter&lt;/a&gt;（&lt;a href=&quot;#footer&quot;&gt;Footer&lt;/a&gt; 那个，魔改自 &lt;a href=&quot;https://github.com/kotx/moco&quot;&gt;moco&lt;/a&gt;），但是统计面板不想公开，所以自然需要一个鉴权方式。我选择了 &lt;strong&gt;Passkey&lt;/strong&gt;，也借此搞通了 Passkey 的验证流程。&lt;/p&gt; &lt;h2&gt;为什么选择 Passkey?&lt;/h2&gt; &lt;p&gt;我不喜欢输密码，基于公钥认证的系统让我感觉更安心。就像使用 SSH，我也是仅支持公钥验证，完全不需要密码，安全性更高且劝退暴力破解者。&lt;/p&gt; &lt;p&gt;对于普通用户，Passkey 解决了密码泄露、钓鱼攻击等问题，简化了身份验证流程（无需额外的 2FA）。&lt;/p&gt; &lt;h2&gt;不足之处&lt;/h2&gt; &lt;p&gt;Passkey 通常绑定到设备或其生态系统（如 iCloud、Google 账号）。目前，除了使用 &lt;strong&gt;KeePassXC&lt;/strong&gt; 外，几乎没有导出和导入的手段。 更换设备或丢失绑定设备时，可能会面临身份验证困难。 &lt;a href=&quot;https://blog.1password.com/fido-alliance-import-export-passkeys-draft-specs/&quot;&gt;未来或许会有更多密码管理器支持&lt;/a&gt;。 [^1]&lt;/p&gt; &lt;p&gt;Passkey 必需依赖 Javascript，不能纯 HTML 了。 [^2]&lt;/p&gt; &lt;p&gt;[^1]: &lt;a href=&quot;https://fidoalliance.org/specs/cx/cxf-v1.0-wd-20240522.html&quot;&gt;Credential Exchange Format&lt;/a&gt;&lt;/p&gt; &lt;p&gt;[^2]: &lt;a href=&quot;https://github.com/w3c/webauthn/issues/1255&quot;&gt;Add a way to use webauthn without Javascript · Issue #1255 · w3c/webauthn&lt;/a&gt;&lt;/p&gt; &lt;h2&gt;注册与登录流程&lt;/h2&gt; &lt;h3&gt;注册流程&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-d2&quot;&gt;shape: sequence_diagram User -&amp;gt; Frontend: Username Frontend -&amp;gt; Backend: /api/registerStart (username) Backend -&amp;gt; Frontend: publicKeyCredentialCreationOptions Frontend -&amp;gt; User: Trigger credentials.create User -&amp;gt; Frontend: User auth Frontend -&amp;gt; Backend: /api/registerFinish (attestation) Backend -&amp;gt; Backend: VerifyAndSave (attestation) Backend -&amp;gt; Frontend: Creation &lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;登录流程&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-d2&quot;&gt;shape: sequence_diagram User -&amp;gt; Frontend: Username (optional) Frontend -&amp;gt; Backend: /api/loginStart (username) Backend -&amp;gt; Frontend: publicKeyCredentialRequestOptions Frontend -&amp;gt; User: Trigger credentials.get User -&amp;gt; Frontend: User auth Frontend -&amp;gt; Backend: /api/loginFinish (assertion) Backend -&amp;gt; Backend: Verify (assertion) Backend -&amp;gt; Frontend: Login successful &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;API 使用指南&lt;/h2&gt; &lt;h3&gt;环境要求&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;服务端需要支持 &lt;strong&gt;HTTPS&lt;/strong&gt;，也可以是 &lt;code&gt;localhost&lt;/code&gt;（WebAuthn 需要 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;Secure contexts&lt;/a&gt;）。&lt;/li&gt; &lt;li&gt;后端推荐使用现成的库，比如 Node.js 的 &lt;a href=&quot;https://github.com/MasterKale/SimpleWebAuthn&quot;&gt;simplewebauthn&lt;/a&gt;。不然验证挺繁琐的。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;下面都算伪代码，实际操作中 ArrayBuffer 编码为 Base64URL &lt;/p&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;p&gt;前端需要输入用户名，请求 &lt;code&gt;/api/registerStart&lt;/code&gt;，获取 &lt;code&gt;publicKeyCredentialCreationOptions&lt;/code&gt;。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const publicKeyCredentialCreationOptions = { challenge: Uint8Array.from( randomStringFromServer, c =&amp;gt; c.charCodeAt(0)), rp: { name: &amp;quot;Meow Counter&amp;quot;, id: &amp;quot;example.com&amp;quot;, // 浏览器会验证当前域名与 RP ID 是否匹配 }, user: { id: Uint8Array.from( &amp;quot;UZSL85T9AFC&amp;quot;, c =&amp;gt; c.charCodeAt(0)), name: &amp;quot;lee@example.com&amp;quot;, displayName: &amp;quot;Lee&amp;quot;, }, pubKeyCredParams: [{ alg: -7, type: &amp;quot;public-key&amp;quot; }], // 接受的算法 authenticatorSelection: { authenticatorAttachment: &amp;quot;cross-platform&amp;quot;, // 平台外部认证器 }, timeout: 60000, attestation: &amp;quot;direct&amp;quot; }; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;challenge&lt;/strong&gt;:&lt;/p&gt; &lt;p&gt;&lt;code&gt;challenge&lt;/code&gt; 应该是一次性且短期有效的，使用后作废&lt;/p&gt; &lt;ul&gt; &lt;li&gt;challenge 在 KV 中存储，应使用 Expired key。&lt;/li&gt; &lt;li&gt;每次请求新的 challenge，旧 challenge 立即作废。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;rp&lt;/strong&gt;: &lt;/p&gt; &lt;p&gt;假设你的 RP ID 设置为 example.com，只有在 example.com 或其子域 login.example.com 上调用 Passkey，验证会成功。&lt;/p&gt; &lt;p&gt;&lt;strong&gt;authenticatorAttachment&lt;/strong&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;platform：使用本地认证器（如 Windows Hello、Face ID）。&lt;/li&gt; &lt;li&gt;cross-platform：使用外部认证器（如 YubiKey，密码管理器）。&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;前端创建凭据&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const credential = await navigator.credentials.create({ publicKey: publicKeyCredentialCreationOptions }); console.log(credential); PublicKeyCredential { id: &amp;#39;ADSUllKQmbqdGtpu4sjseh4cg2TxSvrbcHDTBsv4NSSX9...&amp;#39;, rawId: ArrayBuffer(59), response: AuthenticatorAttestationResponse { clientDataJSON: ArrayBuffer(121), attestationObject: ArrayBuffer(306), }, type: &amp;#39;public-key&amp;#39; } post(&amp;#39;/api/registerFinish&amp;#39;, { credential }); &lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;服务端验证注册&lt;/h4&gt; &lt;p&gt;服务端需要保存 &lt;code&gt;challenge&lt;/code&gt;，以供验证使用。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const { verifyRegistrationResponse } = require(&amp;#39;@simplewebauthn/server&amp;#39;); const verification = verifyRegistrationResponse({ response: clientResponse, // 前端返回的凭证数据 expectedChallenge: storedChallenge, expectedOrigin: &amp;quot;https://example.com&amp;quot;, expectedRPID: &amp;quot;example.com&amp;quot;, }); if (verification.verified) { saveToDatabase({ credentialID: verification.registrationInfo.credentialID, publicKey: verification.registrationInfo.credentialPublicKey, }); } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;verifyRegistrationResponse&lt;/code&gt; 会解析 &lt;code&gt;clientDataJSON&lt;/code&gt;，将 &lt;code&gt;challenge&lt;/code&gt; 与之前保存的进行比较以验证是否对应于当前注册事件。然后从 &lt;code&gt;attestationObject&lt;/code&gt; 中获取 &lt;code&gt;credential.id&lt;/code&gt; 和 &lt;code&gt;publicKey&lt;/code&gt;，并将它们存储到数据库中。&lt;/p&gt; &lt;h3&gt;用户登录&lt;/h3&gt; &lt;h4&gt;服务端生成 challenge&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const publicKeyCredentialRequestOptions = { challenge: Uint8Array.from( randomStringFromServer, c =&amp;gt; c.charCodeAt(0)), allowCredentials: [{ id: Uint8Array.from( credentialId, c =&amp;gt; c.charCodeAt(0)),// optional，注册时保存的 credentialID type: &amp;quot;public-key&amp;quot;, transports: [&amp;quot;usb&amp;quot;, &amp;quot;ble&amp;quot;, &amp;quot;nfc&amp;quot;], // 支持的认证器传输方式 }], timeout: 60000, }; &lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;前端触发认证&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const assertion = await navigator.credentials.get({ publicKey: publicKeyCredentialRequestOptions }); console.log(assertion); PublicKeyCredential { id: &amp;#39;ADSUllKQmbqdGtpu4sjseh4cg2TxSvrbcHDTBsv4NSSX9...&amp;#39;, rawId: ArrayBuffer(59), response: AuthenticatorAssertionResponse { authenticatorData: ArrayBuffer(191), clientDataJSON: ArrayBuffer(118), signature: ArrayBuffer(70), userHandle: ArrayBuffer(10), // optional, 注册时提供的用户ID。用于与服务器上的用户关联起来。服务端未提供 allowCredentialDescriptorList 的时候，服务端可以通过 userHandle 确定用户。 }, type: &amp;#39;public-key&amp;#39; } post(&amp;#39;/api/loginFinish&amp;#39;, { assertion }); &lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;服务端验证登录&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const { verifyAuthenticationResponse } = require(&amp;#39;@simplewebauthn/server&amp;#39;); const verification = verifyAuthenticationResponse({ response: clientResponse, // 前端返回的数据 expectedChallenge: storedChallenge, expectedOrigin: &amp;quot;https://example.com&amp;quot;, expectedRPID: &amp;quot;example.com&amp;quot;, credential: storedCredential, // 注册时保存的 credentialId 和 publicKey }); if (verification.verified) { // 用户验证成功 grantAccessToUser(); } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;verifyAuthenticationResponse 验证 signature 和 clientDataJSON 是否与存储的 publicKey 匹配，确认登录成功。&lt;/p&gt; </content:encoded></item><item><title>影响汇率的因素</title><link>https://icealtria.github.io/blog/exchange-rate/<guid ispermalink="true">https://icealtria.github.io/blog/exchange-rate/</guid><description>怎么写金融的文章了(</description><pubDate>Mon, 25 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;应该算笔记。&lt;/p&gt; &lt;h2&gt;物价&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;&lt;p&gt;&lt;strong&gt;购买力平价理论（PPP）&lt;/strong&gt;&lt;br&gt;购买力平价理论认为，长期汇率由不同国家的物价水平决定。然而，因贸易成本、管制等实际因素，PPP 实际偏离较大。&lt;/p&gt; &lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;strong&gt;通货膨胀&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;通胀差异&lt;/strong&gt;才能决定汇率走向核心，而不是单纯看绝对的通胀水平。若本国通胀高于外国，则其货币在长期内往往会贬值。 但大多数国家的通胀率相对稳定，容易被其他因素掩盖。&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;利率&lt;/h2&gt; &lt;p&gt;利率越高，汇率越高。通胀水平较高时，央行通常也会通过提高利率来控制通胀。&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;p&gt;&lt;strong&gt;利差效应&lt;/strong&gt;&lt;br&gt;投资者借入低利率货币（如日元，利率接近 0%），兑换为高利率货币（如美元，利率超 5%）以获利。（2024）&lt;/p&gt; &lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;strong&gt;资本流动&lt;/strong&gt;&lt;br&gt;高利率国家的债券或存款产品吸引国际投资者资金流入，增加该国货币需求。&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; &lt;h3&gt;案例&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;美元&lt;/strong&gt; 2022 年美联储加息周期，美元迅速升值，因其利率相较其他发达国家更高，吸引了大量国际资本流入。 &lt;/li&gt; &lt;li&gt;&lt;strong&gt;日元&lt;/strong&gt; 日本央行长期实施低利率政策，导致日元相对弱势。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;&lt;strong&gt;扩展：利差交易&lt;/strong&gt;（挖坑）&lt;/p&gt; &lt;/blockquote&gt; &lt;h2&gt;国际收支&lt;/h2&gt; &lt;p&gt;国际收支（Balance of Payments, BOP）统计一个国家的所有对外经济活动，包括两大账户： &lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;经常账户&lt;/strong&gt;&lt;br&gt;包括贸易顺差/逆差（出口 - 进口）、服务贸易、投资收益和跨国转移。 &lt;/li&gt; &lt;li&gt;&lt;strong&gt;资本账户&lt;/strong&gt;&lt;br&gt;记录外资流入和本国对外投资。&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;盈余与赤字对汇率的影响&lt;/h3&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th&gt;外汇流向&lt;/th&gt; &lt;th&gt;对汇率的影响&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;tr&gt; &lt;td&gt;&lt;strong&gt;盈余&lt;/strong&gt;&lt;/td&gt; &lt;td&gt;外汇流入 &amp;gt; 外汇流出&lt;/td&gt; &lt;td&gt;需求 &amp;gt; 供给，推动本币升值&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;strong&gt;赤字&lt;/strong&gt;&lt;/td&gt; &lt;td&gt;外汇流入 &amp;lt; 外汇流出&lt;/td&gt; &lt;td&gt;供给 &amp;gt; 需求，导致本币贬值&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;p&gt;国际收支平衡下，经常账户和资本账户的资金流动会互相抵消，汇率影响较小。如果某一账户长期处于盈余或赤字状态，则会产生更显著的汇率压力。&lt;/p&gt; &lt;h3&gt;案例&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;中国双顺差（-2014）&lt;/strong&gt;&lt;br&gt;经常账户和资本账户同时盈余，人民币单边升值。 &lt;/li&gt; &lt;li&gt;&lt;strong&gt;美国的逆差与盈余&lt;/strong&gt;&lt;br&gt;经常账户长期赤字，但资本账户盈余，两者相抵后，美元保持均衡状态。&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;央行政策&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;外汇管制&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;公开市场操作&lt;/strong&gt;&lt;br&gt;例如中央银行通过购买或出售政府债券&lt;/li&gt; &lt;li&gt;&lt;strong&gt;货币挂钩&lt;/strong&gt;&lt;br&gt;如果某国选择将货币与美元挂钩（如港币与美元挂钩），这需要持有大量美元储备以保持货币稳定。&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;风险&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;政治风险&lt;/strong&gt;&lt;br&gt;政局不稳会引发资本外逃，导致货币贬值。&lt;br&gt;例子：英国脱欧、土耳其政策的不确定性和地缘政治风险。&lt;span class=&quot;hidden-text&quot;&gt;interest rates are the mother of all evils (&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;自然灾害与意外事件&lt;/strong&gt;&lt;br&gt;通常会引起货币贬值。不过这也有些不寻常之事：2011年日本海啸后，日元反而升值。由于借入日元的成本低，它成为了套利交易的基础货币。风险来临之际，通常会有大量套利交易平仓以避险，从而推升日元价值。&lt;/li&gt; &lt;/ul&gt; </content:encoded></item><item><title>给运行在局域网内的服务添加 https</title><link>https://icealtria.github.io/blog/https-lan/<guid ispermalink="true">https://icealtria.github.io/blog/https-lan/</guid><description>使用 Tailscale 实现</description><pubDate>Mon, 06 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;这是一个很奇怪的需求，在大多数情况下，局域网内的设备是相互信任的，https 似乎是件没有什么必要的事情。&lt;/p&gt; &lt;p&gt;但是有些软件要求必须使用 HTTPS，比如 Vaultwarden，因为它依赖大多数浏览器仅在 HTTPS 才可用的 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto&quot;&gt;SubtleCrypto API&lt;/a&gt;。[^1] 此外，一些软件在未开启 HTTPS 时，会在页面上显示不安全的提示。还有一些软件若不开启 https ，则会在页面上显示不安全的提示。这时候 https 就有必要了。&lt;/p&gt; &lt;p&gt;[^1]:&lt;a href=&quot;https://github.com/dani-garcia/vaultwarden/wiki/Enabling-HTTPS&quot;&gt;Enabling HTTPS · dani-garcia/vaultwarden Wiki · GitHub&lt;/a&gt;&lt;/p&gt; &lt;p&gt;之后我用搜索引擎搜了下有关这方面的内容，大部分都是用通过自签证书实现的。这确实是实现 HTTPS 的一种常见方法，但在多台机器上配置自签证书比较繁琐。&lt;/p&gt; &lt;p&gt;对于 Tailscale 用户来说，只需要少量配置即可实现 HTTPS。Tailscale 的 Tailnet 提供域名和证书生成功能，通过 &lt;code&gt;tailscale serve&lt;/code&gt; 命令，可以轻松反向代理服务并提供 HTTPS 支持。如果需要更复杂的配置，可以使用 Caddy。Caddy 遇到 &lt;code&gt;*.ts.net&lt;/code&gt; 域名时，会自动从 Tailscale 获取证书。我的个人设备几乎都连接了 Tailscale。&lt;/p&gt; &lt;h2&gt;如何配置&lt;/h2&gt; &lt;h3&gt;tailscale serve&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;打开 console 的 &lt;a href=&quot;https://login.tailscale.com/admin/dns&quot;&gt;&lt;strong&gt;DNS&lt;/strong&gt;&lt;/a&gt; 页面。&lt;/li&gt; &lt;li&gt;确保 MagicDNS 和 HTTPS Certificates 都为开启状态 &lt;img src=&quot;image.png&quot; alt=&quot;DNS Settings&quot;&gt;&lt;/li&gt; &lt;li&gt;执行以下命令：&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;tailscale serve --bg --https=443 localhost:&amp;lt;port&amp;gt; &lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;之后，就可以通过在 Tailscale 设置好的域名访问服务了。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;把 serve 换成 funnel，则可以将服务暴露在互联网。&lt;/p&gt; &lt;/blockquote&gt; &lt;h3&gt;Caddy&lt;/h3&gt; &lt;p&gt;从 Caddy 2.5 测试版开始，Caddy 支持与 Tailscale 集成。当 Caddy 收到 &lt;code&gt;*.ts.net&lt;/code&gt; 域名的 HTTPS 请求时，会自动从本地 Tailscale 守护程序获取证书，无需额外配置。&lt;/p&gt; &lt;p&gt;配置示例如下：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;machine-name.domain-alias.ts.net { handle_path /vw/* { reverse_proxy http://127.0.0.1:8089 } handle_path /alist/* { reverse_proxy http://127.0.0.1:5244 } } &lt;/code&gt;&lt;/pre&gt; </content:encoded></item><item><title>终究还是用回了 Syncthing</title><link>https://icealtria.github.io/blog/syncthing/<guid ispermalink="true">https://icealtria.github.io/blog/syncthing/</guid><description>主要是吐槽 Dropbox</description><pubDate>Wed, 10 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;我使用过的同步软件&lt;/h2&gt; &lt;p&gt;我在很长一段时间里一直使用 Dropbox，MegaSync 也用过一段时间。至于为什么选择这两个，是因为主流网盘中提供 Linux 客户端的除了 PCloud 就只有这两个了。&lt;/p&gt; &lt;p&gt;起初我在用 Mega，因为我将密码管理器从 Bitwarden 更换为 KeePassXC，我想将密码库同步到手机上，但当时 KeePass2Android 不支持。现在虽然支持了，但还没完全支持，例如无法登录开启 &lt;a href=&quot;https://github.com/PhilippC/keepass2android/issues/2415&quot;&gt;2FA&lt;/a&gt; 的账号，而 KeePassDX 也用不了。Dropbox 支持在系统的文件选择器中选择文件，因此手机上的两个软件都可以支持。&lt;/p&gt; &lt;p&gt;不过我最终还是放弃了这两个云同步软件，只留下了 Syncthing。Syncthing 我其实一直在用，但之前都只是在电脑上使用。对于在手机上使用，我曾担心它会耗电，但后来发现这个担心是多余的。&lt;/p&gt; &lt;h2&gt;批评 Dropbox&lt;/h2&gt; &lt;p&gt;为什么要抛弃 Dropbox，那要从我给 Obsidian 写一个插件说起。Obsidian 的插件是用 JavaScript 编写的，每个 JS 项目都会有一坨 &lt;code&gt;node_modules&lt;/code&gt;，然后它把这个文件夹同步过去。&lt;/p&gt; &lt;p&gt;我以为在 GUI 里设置选择性同步可以忽略掉这个文件夹，但我搞错了。Dropbox 只能用一种很别扭的方式忽略一个文件夹：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# linux attr -s com.dropbox.ignored -V 1 &amp;#39;/home/yourname/Dropbox (Personal)/YourFileName.pdf&amp;#39; # windog Set-Content -Path &amp;#39;C:\Users\yourname\Dropbox(Personal)\YourFileName.pdf&amp;#39; -Stream com.dropbox.ignored -Value 1 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;这就没办法在文件创建之前忽略掉这个文件了，想忽略多个文件还要逐个操作。&lt;/p&gt; &lt;p&gt;而 syncthing 和 MEGA 只需要简单写个规则。&lt;/p&gt; &lt;p&gt;不止如此。。。&lt;/p&gt; &lt;p&gt;Dropbox 只能将本地的一个文件夹与服务器同步，但我不喜欢将一切都放到 &lt;del&gt;/Dropbox。我希望能将 `&lt;/del&gt;/Docs&lt;code&gt;与&lt;/code&gt;%USERPROFILE%/Docs&lt;code&gt;，&lt;/code&gt;~/Books&lt;code&gt;与&lt;/code&gt;D:/Books` 同步。&lt;/p&gt; &lt;p&gt;Syncthing 和 Mega 都能做到。&lt;/p&gt; &lt;p&gt;在 Gnome 上 Dropbox 的托盘完全是坏的，这个问题存在了数年，虽然不知道是谁的锅，但只在 Dropbox 上遇到过。右键点击托盘图标打开菜单只能随缘，即便打开显示的状态也是不更新的，永远 &amp;quot;Connecting...&amp;quot;，当然实际上工作的。它只能作为设置页的入口。&lt;/p&gt; &lt;p&gt;同步相关的功能比 Syncthing 和 Mega 更匮乏，但占用内存却是最大的。&lt;/p&gt; &lt;p&gt;槽点这么多，那干脆不用了。我都不知道为什么忍了它这么久。&lt;/p&gt; &lt;p&gt;(说起来 MEGAsync 算是我较为满意的一个网盘了)&lt;/p&gt; &lt;h2&gt;如何实现 3-2-1 备份&lt;/h2&gt; &lt;p&gt;我使用同步软件的其中一个原因是希望实现 3-2-1 备份，以避免本地机器故障。所谓 3-2-1 备份策略，即保存三份数据备份，使用两种不同的存储介质，并确保至少有一份备份存储在异地。&lt;/p&gt; &lt;p&gt;为了实现这个策略，我采用了 Restic 进行定期备份。它支持数据加密和压缩快照。还可以调用 rclone 的服务作为远程 repo。&lt;/p&gt; &lt;p&gt;具体来说，我编写了一个定期执行的脚本，通过 Restic 进行备份操作。为了确保备份的安全性，我将备份库（repo）的密码存储在 Gnome Keyring 中。脚本会调用 &lt;code&gt;secret-tool&lt;/code&gt; 从 Gnome Keyring 中取出密码，并用来解密备份库进行备份。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;restic -r rclone:&amp;lt;remote&amp;gt;:/path/to/repo backup /path/to/data --password-command &amp;#39;secret-tool lookup restic pass&amp;#39; &lt;/code&gt;&lt;/pre&gt; </content:encoded></item><item><title>我又回来了</title><link>https://icealtria.github.io/blog/first-post/<guid ispermalink="true">https://icealtria.github.io/blog/first-post/</guid><description>这次要徒手搓博客</description><pubDate>Thu, 21 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;曾经几度对自己的博客开了又关，最初一个博客应该是在读初中的时候建起来的，使用的是 wordpress。但都没写什么文章，每次想写点什么，就觉得没什么好写的，或者写不出来。。等域名过期或是vps过期，然后也就这么丢掉了。比起写博客还是建博客比较好玩😊况且有了生成式人工智能，写作负担会小很多。&lt;/p&gt; &lt;h2&gt;框架选择&lt;/h2&gt; &lt;p&gt;我对前端不是很熟悉，SSG(Static Site Generator) 框架除了主流的 Hexo, Hugo, Jekyll 之外，我几乎不认识其他的。这几个框架在我看来都不是很灵活（不好整活）。&lt;/p&gt; &lt;p&gt;正好我发现某位页面仔群友也在用重写博客，使用了 Astro。之后我也去了解一下关于这框架的 features，令我比较感兴趣的是 &lt;a href=&quot;https://docs.astro.build/en/concepts/islands/&quot;&gt;Component Islands&lt;/a&gt;，它可以使用任何被支持的UI框架（比如 React, Svelte, Vue）作为组件，还有 MDX，这就相当有利于整活。SSR 的支持也是有的，以后可能会用来显示动态内容，比如评论。于是就选择了 Astro。&lt;/p&gt; &lt;h2&gt;目标&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 很快的页面打开速度&lt;/li&gt; &lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 无障碍&lt;/li&gt; &lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 搜索引擎友好&lt;/li&gt; &lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; w3m 友好&lt;/li&gt; &lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 尽可能避免 JS&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;大概就是灯塔跑分要4个100，最初设定的目标算是达到了。&lt;/p&gt; &lt;h2&gt;过程记录&lt;/h2&gt; &lt;h3&gt;设计&lt;/h3&gt; &lt;p&gt;起初，我打算根据 Material You 的风格来设计我的博客，也就是现在(2023) Google 的设计语言。我模仿了 Material 官网的超大的R角(Radius: 40px)，但后来我发现，过大的圆角严重影响了内容的展示。这里的逻辑是，为了看起来更协调，大圆角需要足够的留白，这就导致了内容展示的空间变少了。有空我一定要写一篇《圆角批判》!&lt;/p&gt; &lt;p&gt;色彩方面使用了 &lt;a href=&quot;https://m3.material.io/theme-builder&quot;&gt;Material Theme Builder&lt;/a&gt; 进行调色。后面为了方便使用了 &lt;a href=&quot;https://github.com/JavierM42/tailwind-material-colors&quot;&gt;tailwind-material-colors&lt;/a&gt; 作为插件，只要设定一个 primary color 就能计算出其他的颜色，DarkMode 也自动适配好了。 写这篇博客的时候，使用了 &lt;span style=&quot;background-color: #405e0d; color:white&quot;&gt;#405e0d&lt;/span&gt; 作为主题色。以后看心情换。&lt;/p&gt; &lt;h3&gt;CSS&lt;/h3&gt; &lt;p&gt;初版使用纯正的 CSS 进行页面布局，写着写着越来越乱了，第一次写规模稍大的页面，不知怎么管理 CSS。后面使用 Tailwind CSS 负担小了很多，首先不用 template 和 css 来回切，不知不觉找不着 tab 了。如果要问为什么不写在 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;，因为我不想看到 Network 里一大堆 stylesheet（这什么强迫症），实际上对加载速度也没很大影响。&lt;/p&gt; &lt;h2&gt;最后的话&lt;/h2&gt; &lt;p&gt;接下来，我将继续优化和完善这个博客，还有很多想法没实现呢。就这样。&lt;/p&gt; </content:encoded></item><item><title>折腾日记：尝试将影片库到云端</title><link>https://icealtria.github.io/blog/cloud-jellyfin/<guid ispermalink="true">https://icealtria.github.io/blog/cloud-jellyfin/</guid><description>简单的说下我迁移影片到云端的过程，还有坑。使用的是 alist 和天翼盘。</description><pubDate>Mon, 13 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近，我偶然发现了一个名为 alist 的项目，它能挂载多款国内的网盘，并支持 WebDav 协议。然后我想到了祖传的 10T 天翼网盘。于是，我产生了一个令人兴奋的想法：将 NAS 中的影片移动到网盘上，并使用 webdav 协议在 kodi 中进行播放。在这篇文章中，我将记录下我如何实现这个想法和坑。&lt;/p&gt; &lt;h2&gt;准备工作&lt;/h2&gt; &lt;p&gt;首先，我们需要安装 Alist。这是一个非常简单的过程，只需遵循安装说明并进行操作即可。作为安装的方法，我选择了使用 docker compose 进行安装。&lt;/p&gt; &lt;p&gt;天翼网盘免费版一天只有 2G 上传，想要更大的上传只能购买会员。电信用户可以到积分商城兑换，1000 积分一个月。&lt;/p&gt; &lt;p&gt;在登录管理面板后，我们需要添加网盘。alist 支持天翼网盘和天翼网盘客户端。对于大于 4 GB 的文件，必须使用天翼网盘客户端。&lt;/p&gt; &lt;h2&gt;迁移工作&lt;/h2&gt; &lt;p&gt;既然 alist 支持 WebDav 了，我决定选择使用 rclone 进行文件迁移。sync 命令比通过网页传输方便得多。此外，我还有一些影片尚未刮削元数据，使用 sync 命令可以将我在本地对影片的修改同步到远端。并且如果传输过程中出现问题，也容易处理。&lt;/p&gt; &lt;h2&gt;评估&lt;/h2&gt; &lt;p&gt;在使用 alist 把影片迁移到网盘后，我惊讶地发现它的播放效果非常流畅，即使是 16Mbps 的高码率视频，拖动播放进度条也能立即加载。这个体验相比许多在线流媒体服务都更出色。（会员过期后，拖动进度条缓冲时间大概为 1 秒）&lt;/p&gt; &lt;p&gt;然而，在搜索影片的元数据时，速度可能会有所不足，需要一些等待时间。我猜测这可能是由于文件数量过多，于是我决定删除部分每集的缩略图和不必要的海报以提升速度。然后，我遇到了以下原因不明的异常行为。&lt;/p&gt; &lt;h2&gt;坑&lt;/h2&gt; &lt;p&gt;我使用 rclone sync 命令，将我在 NAS 的删除操作同步到远端，但文件只被删除了一部分。命令执行的很快，执行过程中也没发生报错，到 alist 网页中看到文件被删除，但我到网盘页面看到只删除了一部分。接着我刷新 alist 的文件列表，果然还在，这个就很。。到时候再研究下怎么回事了。之前我上传文件的时候出现过几次错误，但之后重试后都顺利完成了（rclone sync 失败后会重新尝试 2 次）。&lt;/p&gt; &lt;h2&gt;总结&lt;/h2&gt; &lt;p&gt;总的来说，使用网盘作为影片库与 kodi 观看的体验很不错，但是天翼盘不付费的上传体验糟糕。迁移后 NAS 硬盘空间非常充裕，可以不用买新硬盘了。但 alist 通过 WebDav 进行某些操作文件时不是很稳定，除了视频播放。&lt;/p&gt; &lt;h2&gt;后记&lt;/h2&gt; &lt;p&gt;之后换了 Rclone + Jellyfin，Kodi 每次要等打开电视才扫描片库。使用 rclone mount 将 WebDav 挂载到其中一个目录，然后添加到 Jellyfin，体验要远远好于 kodi。&lt;/p&gt; </content:encoded></item><item><title>CanoKey NFC-A 开箱体验</title><link>https://icealtria.github.io/blog/canokey-unboxing/<guid ispermalink="true">https://icealtria.github.io/blog/canokey-unboxing/</guid><description>Yubikey 平替</description><pubDate>Tue, 02 Feb 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;这是 eraly bird，不是 pigeon。&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;说下购买的原因，我一直想买一个替代Key，无奈Yubikey售价太高，然后恰好在某群组看到Canokey发售的消息。&lt;/p&gt; &lt;p&gt;目前发售的CanoKey拥有Yubikey 5 NFC大部分功能，早起的鸟儿只需要79+10（运费），价格不到Yubikey的四分一。正式版据说也不会太贵。&lt;/p&gt; &lt;h2&gt;开箱&lt;/h2&gt; &lt;p&gt;外包装是牛皮纸，看上去很环保。本体有滴胶保护，防水且坚固。 &lt;img src=&quot;https://github.com/icealtria/picx-images-hosting/raw/images/20231022/CanoKey.webp&quot; alt=&quot;Canokey&quot;&gt;&lt;/p&gt; &lt;h2&gt;它能做什么&lt;/h2&gt; &lt;p&gt;支持的协议&lt;/p&gt; &lt;ul&gt; &lt;li&gt;U2F / FIDO2&lt;/li&gt; &lt;li&gt;OpenPGP&lt;/li&gt; &lt;li&gt;PIV&lt;/li&gt; &lt;li&gt;HOTP / TOTP&lt;/li&gt; &lt;li&gt;NDEF&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Yubikey能做的Canokey基本都能做。我自己平时用的功能大多都覆盖到，除了KeepassXC中的Challenge-Response。并且大部分功能使用方法跟Yubikey一致，甚至还可以使用ykman（YubiKey Manager CLI）管理PIV。所以Canokey支持的特性很多都可以参考&lt;a href=&quot;https://github.com/drduh/YubiKey-Guide&quot;&gt;Yubikey Guide&lt;/a&gt;。&lt;/p&gt; &lt;p&gt;个人最常用的还是U2F，OpenPGP Card。使用U2F作为MFA的一种方式，相比TOTP能更好地对抗钓鱼，社工。而OpenPGP Card可以保护私钥不被盗取。&lt;/p&gt; &lt;p&gt;另外支持64个FIDO2 resident keys，相比之下Yubikey 5只有25个。&lt;/p&gt; &lt;h2&gt;不爽的地方&lt;/h2&gt; &lt;p&gt;客户端是网页的，需要Chromium内核的浏览器。我觉得还是有个本地运行的客户端更好，不过客户端开源，可以clone项目到本地，在node环境运行。&lt;/p&gt; &lt;p&gt;目前TOTP只在网页使用，很不方便。&lt;/p&gt; &lt;p&gt;OpenSSH 8.2版本开始支持FIDO/U2F安全密钥。但Canokey只支持ecdsa-sk，不支持ed25519-sk。有点遗憾，但也还好。&lt;/p&gt; &lt;p&gt;NFC灵敏度要比Yubikey低很多，偶尔会出现失败的现象。&lt;/p&gt; &lt;h2&gt;总结&lt;/h2&gt; &lt;p&gt;目前市面上在单个硬件实现多种协议的Key并不多，而且价格对比Yubikey也没有优势。CanoKey能够支持其大部分核心功能，日常使用基本能够满足需求，后续正式版价格不高的话非常值得入手。&lt;/p&gt; </content:encoded></item></channel></rss>